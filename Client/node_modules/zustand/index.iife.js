var zustand = (function (exports, react) {
  'use strict';

  var forceUpdateReducer = function forceUpdateReducer(state) {
    return state + 1;
  }; // For server-side rendering: https://github.com/react-spring/zustand/pull/34


  var useIsoLayoutEffect = typeof window === 'undefined' ? react.useEffect : react.useLayoutEffect;
  function create(createState) {
    var state;
    var listeners = new Set();

    var setState = function setState(partial) {
      var partialState = typeof partial === 'function' ? partial(state) : partial;

      if (partialState !== state) {
        state = Object.assign({}, state, partialState);
        listeners.forEach(function (listener) {
          return listener();
        });
      }
    };

    var getState = function getState() {
      return state;
    };

    var subscribe = function subscribe(listener, options) {
      if (options === void 0) {
        options = {};
      }

      if (!('currentSlice' in options)) {
        options.currentSlice = (options.selector || getState)(state);
      }

      var listenerFn = function listenerFn() {
        // Destructure in the listener to get current values. We rely on this
        // because options is mutated in useStore.
        var _options = options,
            _options$selector = _options.selector,
            selector = _options$selector === void 0 ? getState : _options$selector,
            _options$equalityFn = _options.equalityFn,
            equalityFn = _options$equalityFn === void 0 ? Object.is : _options$equalityFn; // Selector or equality function could throw but we don't want to stop
        // the listener from being called.
        // https://github.com/react-spring/zustand/pull/37

        try {
          var newStateSlice = selector(state);

          if (!equalityFn(options.currentSlice, newStateSlice)) {
            listener(options.currentSlice = newStateSlice);
          }
        } catch (error) {
          options.subscribeError = error;
          listener();
        }
      };

      listeners.add(listenerFn);
      return function () {
        return void listeners["delete"](listenerFn);
      };
    };

    var destroy = function destroy() {
      return listeners.clear();
    };

    var useStore = function useStore(selector, equalityFn) {
      if (selector === void 0) {
        selector = getState;
      }

      if (equalityFn === void 0) {
        equalityFn = Object.is;
      }

      if (Array.isArray(equalityFn)) {
        equalityFn = Object.is;
        console.warn('Zustand: the 2nd arg for dependencies was deprecated in 1.0. Please remove it! See: https://github.com/react-spring/zustand#selecting-multiple-state-slices');
      }

      var isInitial = react.useRef(true);
      var options = react.useRef( // isInitial prevents the selector from being called every render.
      isInitial.current && {
        selector: selector,
        equalityFn: equalityFn,
        currentSlice: (isInitial.current = false, selector(state))
      }).current; // Update state slice if selector has changed or subscriber errored.

      if (selector !== options.selector || options.subscribeError) {
        var newStateSlice = selector(state);

        if (!equalityFn(options.currentSlice, newStateSlice)) {
          options.currentSlice = newStateSlice;
        }
      }

      useIsoLayoutEffect(function () {
        options.selector = selector;
        options.equalityFn = equalityFn;
        options.subscribeError = undefined;
      });
      var forceUpdate = react.useReducer(forceUpdateReducer, 1)[1];
      useIsoLayoutEffect(function () {
        return subscribe(forceUpdate, options);
      }, []);
      return options.currentSlice;
    };

    var api = {
      setState: setState,
      getState: getState,
      subscribe: subscribe,
      destroy: destroy
    };
    state = createState(setState, getState, api);
    return [useStore, api];
  }

  exports.create = create;
  exports.default = create;

  return exports;

}({}, React));
